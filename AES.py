import itertools
from Cryptodome.Cipher import AES
import hashlib

#тут пример вывода  ключа в обчном режиме
# key = hashlib.sha256(b"964").digest() #964 - мой пароль, который я выбрал рандомно
# print("Key:", key)

#Рекомендую укахать другой хэш текста. Мой будет Test case
cipher_text = b"\xd8\x88|\x13q{\x86\xbb\xe3i\xab\xc4r\x1b\xf8+12\x8b'\xa5\x85R\x94\xddC6\x99\xc6\xf5\xe3\xa7"

arrKeys = [] #создаем  массив куда будем записывать все значения 000 до 999
chars = "1234567890" #это для создания комбинации цифр (некторая строка байт), из которых будем собирать 3хзначные значения ключа

BS = AES.block_size
unpad = lambda s: s[:-ord(s[len(s) - 1:])]
iv = cipher_text[:BS] #тут перекодируем нач хэш текста(значения из cipher_text) в байты

#тут цикл, который создает все возможные значения от 000 до 999, где itertools - это библиотека,
# а permutations - это метод, который принимает значения из  chars = "1234567890" и ограничивает вариацию 3 цифрами
for i in itertools.permutations(chars, 3):
    arrKeys.append(''.join(i)) #метод append добавляет значения в массив arrKeys, '' - это убираем пробелы между полученными цифрами и
                               # join- это метод, который применяет к полученному значению
                               # иначе было бы, к примеру, 1 2 3 или 5 6 7, вместо этого будет 123 и 567, соотвественно

#тут цикл, который выбирает каждое значение из массива, в который мы записывали все  3х-значные ключи ранее
for j in arrKeys:
    num = (''.join(j)) #num, в данном случае это ключ, т.е. определенное/отдельное 3х-значные значение, которые мы записывали ранее
    key = hashlib.sha256(num.encode()).digest() #сюда мы и подставляем наш num - это, к примеру, тоже самое, если бы подставили 964 или 123
    cipher = AES.new(key, AES.MODE_CBC, iv) #тут декодируем наш ключ
    plain_text = unpad(cipher.decrypt(cipher_text[BS:])) #тут декодируем наш текст
    if plain_text != b'': #тут условие: выводить все варианты декодированного текста, пока текст имеется
        print("Plain text:", plain_text)